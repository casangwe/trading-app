{"ast":null,"code":"// import React, { useEffect, useRef, useState } from \"react\";\n// import \"./styles/accountGraph.css\";\n// import { fetchTrades } from \"./ApiCalls\"; // Importing fetchTrades function\n\n// const AccountGraph = ({}) => {\n//   const chartRef = useRef(null);\n//   const [loading, setLoading] = useState(true);\n//   const [trades, setTrades] = useState([]);\n\n//   useEffect(() => {\n//     const calculateProfitsForAllTimePeriods = (trades) => {\n//       const timePeriods = [\"1D\", \"1W\", \"1M\", \"3M\", \"YTD\", \"1Y\", \"Max\"];\n//       const profitsData = [];\n\n//       timePeriods.forEach((selectedTimePeriod) => {\n//         let startDate = new Date();\n//         let totalProfit = 0;\n\n//         switch (selectedTimePeriod) {\n//           case \"1D\":\n//             startDate.setDate(startDate.getDate() - 1);\n//             break;\n//           case \"1W\":\n//             startDate.setDate(startDate.getDate() - 7);\n//             break;\n//           case \"1M\":\n//             startDate.setMonth(startDate.getMonth() - 1);\n//             break;\n//           case \"3M\":\n//             startDate.setMonth(startDate.getMonth() - 3);\n//             break;\n//           case \"YTD\":\n//             startDate = new Date(startDate.getFullYear(), 0, 1); // Year to Date\n//             break;\n//           case \"1Y\":\n//             startDate.setFullYear(startDate.getFullYear() - 1);\n//             break;\n//           case \"Max\":\n//             break;\n//           default:\n//             break;\n//         }\n\n//         if (selectedTimePeriod !== \"Max\") {\n//           const filteredTrades = trades.filter(\n//             (trade) => new Date(trade.close_date) >= startDate\n//           );\n\n//           totalProfit = filteredTrades.reduce((sum, trade) => {\n//             const entryPrice = parseFloat(trade.entry_price);\n//             const exitPrice = parseFloat(trade.exit_price);\n//             const contracts = trade.contracts;\n//             if (!isNaN(exitPrice)) {\n//               return sum + (exitPrice - entryPrice) * contracts * 100;\n//             }\n//             return sum;\n//           }, 0);\n//         } else {\n//           totalProfit = trades.reduce((sum, trade) => {\n//             const entryPrice = parseFloat(trade.entry_price);\n//             const exitPrice = parseFloat(trade.exit_price);\n//             const contracts = trade.contracts;\n//             if (!isNaN(exitPrice)) {\n//               return sum + (exitPrice - entryPrice) * contracts * 100;\n//             }\n//             return sum;\n//           }, 0);\n//         }\n\n//         profitsData.push({\n//           timePeriod: selectedTimePeriod,\n//           profit: totalProfit,\n//           backgroundColor: totalProfit >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\",\n//         });\n//       });\n\n//       return profitsData;\n//     };\n\n//     const updateChart = () => {\n//       const ctx = chartRef.current.getContext(\"2d\");\n//       const calculatedProfitsData = calculateProfitsForAllTimePeriods(trades);\n\n//       const myChart = new window.Chart(ctx, {\n//         type: \"bar\",\n//         data: {\n//           labels: calculatedProfitsData.map((data) => data.timePeriod),\n//           datasets: [\n//             {\n//               label: \"Profit/Loss\",\n//               data: calculatedProfitsData.map((data) => data.profit),\n//               backgroundColor: calculatedProfitsData.map(\n//                 (data) => data.backgroundColor\n//               ),\n//               barThickness: 40, // Adjust thickness as needed\n//             },\n//           ],\n//         },\n//         options: {\n//           plugins: {\n//             legend: {\n//               display: false,\n//             },\n//           },\n//           scales: {\n//             x: {\n//               grid: {\n//                 display: false,\n//               },\n//             },\n//             y: {\n//               display: true,\n//               title: {\n//                 display: true,\n//                 text: \"Profit/Loss\",\n//               },\n//               grid: {\n//                 color: (context) =>\n//                   context.tick.value === 0\n//                     ? \"rgba(0, 0, 0, 1)\"\n//                     : \"rgba(0, 0, 0, 0)\", // Only show line at 0\n//                 lineWidth: 0.5, // Adjust line width as needed\n//               },\n//               ticks: {\n//                 callback: function (value, index, values) {\n//                   return value === 0 ? value : \"\";\n//                 },\n//               },\n//             },\n//           },\n//         },\n//       });\n\n//       return myChart;\n//     };\n\n//     const fetchData = async () => {\n//       try {\n//         const fetchedTrades = await fetchTrades(); // Fetch trade data\n//         setTrades(fetchedTrades); // Set fetched trade data\n//         setLoading(false); // Set loading state to false\n//       } catch (error) {\n//         console.error(\"Error fetching trades:\", error);\n//         setLoading(false); // Handle loading state in case of error\n//       }\n//     };\n\n//     fetchData(); // Fetch trade data when component mounts\n\n//     let myChart = updateChart();\n//     setLoading(false);\n\n//     return () => {\n//       if (myChart) {\n//         myChart.destroy();\n//       }\n//     };\n//   }, [trades]);\n//   useEffect(() => {\n//     if (!loading) {\n//       const myChart = updateChart(); // Update chart when trade data or loading state changes\n//       return () => {\n//         if (myChart) {\n//           myChart.destroy(); // Destroy chart instance when component unmounts\n//         }\n//       };\n//     }\n//   }, [loading, trades]);\n\n//   return (\n//     <div className=\"account-graph\">\n//       {loading ? <p>Loading...</p> : <canvas ref={chartRef} />}\n//     </div>\n//   );\n// };\n\n// export default AccountGraph;\n// // // import React, { useEffect, useRef } from \"react\";\n// // // import \"./styles/accountGraph.css\";\n\n// // // const AccountGraph = ({ trades, onTimePeriodChange }) => {\n// // //   const chartRef = useRef(null);\n\n// // //   useEffect(() => {\n// // //     const calculateProfitsForAllTimePeriods = (trades) => {\n// // //       const timePeriods = [\"1D\", \"1W\", \"1M\", \"3M\", \"YTD\", \"1Y\", \"Max\"];\n// // //       const profitsData = [];\n\n// // //       timePeriods.forEach((selectedTimePeriod) => {\n// // //         let startDate = new Date();\n// // //         let totalProfit = 0;\n\n// // //         switch (selectedTimePeriod) {\n// // //           case \"1D\":\n// // //             startDate.setDate(startDate.getDate() - 1);\n// // //             break;\n// // //           case \"1W\":\n// // //             startDate.setDate(startDate.getDate() - 7);\n// // //             break;\n// // //           case \"1M\":\n// // //             startDate.setMonth(startDate.getMonth() - 1);\n// // //             break;\n// // //           case \"3M\":\n// // //             startDate.setMonth(startDate.getMonth() - 3);\n// // //             break;\n// // //           case \"YTD\":\n// // //             startDate = new Date(startDate.getFullYear(), 0, 1); // Year to Date\n// // //             break;\n// // //           case \"1Y\":\n// // //             startDate.setFullYear(startDate.getFullYear() - 1);\n// // //             break;\n// // //           case \"Max\":\n// // //             break;\n// // //           default:\n// // //             break;\n// // //         }\n\n// // //         if (selectedTimePeriod !== \"Max\") {\n// // //           const filteredTrades = trades.filter(\n// // //             (trade) => new Date(trade.close_date) >= startDate\n// // //           );\n\n// // //           totalProfit = filteredTrades.reduce((sum, trade) => {\n// // //             const entryPrice = parseFloat(trade.entry_price);\n// // //             const exitPrice = parseFloat(trade.exit_price);\n// // //             const contracts = trade.contracts;\n// // //             if (!isNaN(exitPrice)) {\n// // //               return sum + (exitPrice - entryPrice) * contracts * 100;\n// // //             }\n// // //             return sum;\n// // //           }, 0);\n// // //         } else {\n// // //           totalProfit = trades.reduce((sum, trade) => {\n// // //             const entryPrice = parseFloat(trade.entry_price);\n// // //             const exitPrice = parseFloat(trade.exit_price);\n// // //             const contracts = trade.contracts;\n// // //             if (!isNaN(exitPrice)) {\n// // //               return sum + (exitPrice - entryPrice) * contracts * 100;\n// // //             }\n// // //             return sum;\n// // //           }, 0);\n// // //         }\n\n// // //         profitsData.push({\n// // //           timePeriod: selectedTimePeriod,\n// // //           profit: totalProfit,\n// // //           backgroundColor: totalProfit >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\",\n// // //         });\n// // //       });\n\n// // //       return profitsData;\n// // //     };\n\n// // //     const ctx = chartRef.current.getContext(\"2d\");\n// // //     const profitsData = calculateProfitsForAllTimePeriods(trades);\n\n// // //     const myChart = new window.Chart(ctx, {\n// // //       type: \"bar\",\n// // //       data: {\n// // //         labels: profitsData.map((data) => data.timePeriod),\n// // //         datasets: [\n// // //           {\n// // //             label: \"Profit/Loss\",\n// // //             data: profitsData.map((data) => data.profit),\n// // //             backgroundColor: profitsData.map((data) => data.backgroundColor),\n// // //             barThickness: 40, // Adjust thickness as needed\n// // //           },\n// // //         ],\n// // //       },\n// // //       options: {\n// // //         plugins: {\n// // //           legend: {\n// // //             display: false,\n// // //           },\n// // //         },\n// // //         scales: {\n// // //           x: {\n// // //             grid: {\n// // //               display: false,\n// // //             },\n// // //           },\n// // //           y: {\n// // //             display: true,\n// // //             title: {\n// // //               display: true,\n// // //               text: \"Profit/Loss\",\n// // //             },\n// // //             grid: {\n// // //               color: (context) =>\n// // //                 context.tick.value === 0\n// // //                   ? \"rgba(0, 0, 0, 1)\"\n// // //                   : \"rgba(0, 0, 0, 0)\", // Only show line at 0\n// // //               lineWidth: 0.5, // Adjust line width as needed\n// // //             },\n// // //             ticks: {\n// // //               callback: function (value, index, values) {\n// // //                 return value === 0 ? value : \"\";\n// // //               },\n// // //             },\n// // //           },\n// // //         },\n// // //       },\n// // //     });\n\n// // //     return () => {\n// // //       myChart.destroy();\n// // //     };\n// // //   }, [trades]);\n\n// // //   return (\n// // //     <div className=\"account-graph\">\n// // //       <canvas ref={chartRef} />\n// // //     </div>\n// // //   );\n// // // };\n\n// // // export default AccountGraph;","map":{"version":3,"names":[],"sources":["C:/Users/casan/trading-app/trading-frontend/src/components/AccountGraph.js"],"sourcesContent":["// import React, { useEffect, useRef, useState } from \"react\";\r\n// import \"./styles/accountGraph.css\";\r\n// import { fetchTrades } from \"./ApiCalls\"; // Importing fetchTrades function\r\n\r\n// const AccountGraph = ({}) => {\r\n//   const chartRef = useRef(null);\r\n//   const [loading, setLoading] = useState(true);\r\n//   const [trades, setTrades] = useState([]);\r\n\r\n//   useEffect(() => {\r\n//     const calculateProfitsForAllTimePeriods = (trades) => {\r\n//       const timePeriods = [\"1D\", \"1W\", \"1M\", \"3M\", \"YTD\", \"1Y\", \"Max\"];\r\n//       const profitsData = [];\r\n\r\n//       timePeriods.forEach((selectedTimePeriod) => {\r\n//         let startDate = new Date();\r\n//         let totalProfit = 0;\r\n\r\n//         switch (selectedTimePeriod) {\r\n//           case \"1D\":\r\n//             startDate.setDate(startDate.getDate() - 1);\r\n//             break;\r\n//           case \"1W\":\r\n//             startDate.setDate(startDate.getDate() - 7);\r\n//             break;\r\n//           case \"1M\":\r\n//             startDate.setMonth(startDate.getMonth() - 1);\r\n//             break;\r\n//           case \"3M\":\r\n//             startDate.setMonth(startDate.getMonth() - 3);\r\n//             break;\r\n//           case \"YTD\":\r\n//             startDate = new Date(startDate.getFullYear(), 0, 1); // Year to Date\r\n//             break;\r\n//           case \"1Y\":\r\n//             startDate.setFullYear(startDate.getFullYear() - 1);\r\n//             break;\r\n//           case \"Max\":\r\n//             break;\r\n//           default:\r\n//             break;\r\n//         }\r\n\r\n//         if (selectedTimePeriod !== \"Max\") {\r\n//           const filteredTrades = trades.filter(\r\n//             (trade) => new Date(trade.close_date) >= startDate\r\n//           );\r\n\r\n//           totalProfit = filteredTrades.reduce((sum, trade) => {\r\n//             const entryPrice = parseFloat(trade.entry_price);\r\n//             const exitPrice = parseFloat(trade.exit_price);\r\n//             const contracts = trade.contracts;\r\n//             if (!isNaN(exitPrice)) {\r\n//               return sum + (exitPrice - entryPrice) * contracts * 100;\r\n//             }\r\n//             return sum;\r\n//           }, 0);\r\n//         } else {\r\n//           totalProfit = trades.reduce((sum, trade) => {\r\n//             const entryPrice = parseFloat(trade.entry_price);\r\n//             const exitPrice = parseFloat(trade.exit_price);\r\n//             const contracts = trade.contracts;\r\n//             if (!isNaN(exitPrice)) {\r\n//               return sum + (exitPrice - entryPrice) * contracts * 100;\r\n//             }\r\n//             return sum;\r\n//           }, 0);\r\n//         }\r\n\r\n//         profitsData.push({\r\n//           timePeriod: selectedTimePeriod,\r\n//           profit: totalProfit,\r\n//           backgroundColor: totalProfit >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\",\r\n//         });\r\n//       });\r\n\r\n//       return profitsData;\r\n//     };\r\n\r\n//     const updateChart = () => {\r\n//       const ctx = chartRef.current.getContext(\"2d\");\r\n//       const calculatedProfitsData = calculateProfitsForAllTimePeriods(trades);\r\n\r\n//       const myChart = new window.Chart(ctx, {\r\n//         type: \"bar\",\r\n//         data: {\r\n//           labels: calculatedProfitsData.map((data) => data.timePeriod),\r\n//           datasets: [\r\n//             {\r\n//               label: \"Profit/Loss\",\r\n//               data: calculatedProfitsData.map((data) => data.profit),\r\n//               backgroundColor: calculatedProfitsData.map(\r\n//                 (data) => data.backgroundColor\r\n//               ),\r\n//               barThickness: 40, // Adjust thickness as needed\r\n//             },\r\n//           ],\r\n//         },\r\n//         options: {\r\n//           plugins: {\r\n//             legend: {\r\n//               display: false,\r\n//             },\r\n//           },\r\n//           scales: {\r\n//             x: {\r\n//               grid: {\r\n//                 display: false,\r\n//               },\r\n//             },\r\n//             y: {\r\n//               display: true,\r\n//               title: {\r\n//                 display: true,\r\n//                 text: \"Profit/Loss\",\r\n//               },\r\n//               grid: {\r\n//                 color: (context) =>\r\n//                   context.tick.value === 0\r\n//                     ? \"rgba(0, 0, 0, 1)\"\r\n//                     : \"rgba(0, 0, 0, 0)\", // Only show line at 0\r\n//                 lineWidth: 0.5, // Adjust line width as needed\r\n//               },\r\n//               ticks: {\r\n//                 callback: function (value, index, values) {\r\n//                   return value === 0 ? value : \"\";\r\n//                 },\r\n//               },\r\n//             },\r\n//           },\r\n//         },\r\n//       });\r\n\r\n//       return myChart;\r\n//     };\r\n\r\n//     const fetchData = async () => {\r\n//       try {\r\n//         const fetchedTrades = await fetchTrades(); // Fetch trade data\r\n//         setTrades(fetchedTrades); // Set fetched trade data\r\n//         setLoading(false); // Set loading state to false\r\n//       } catch (error) {\r\n//         console.error(\"Error fetching trades:\", error);\r\n//         setLoading(false); // Handle loading state in case of error\r\n//       }\r\n//     };\r\n\r\n//     fetchData(); // Fetch trade data when component mounts\r\n\r\n//     let myChart = updateChart();\r\n//     setLoading(false);\r\n\r\n//     return () => {\r\n//       if (myChart) {\r\n//         myChart.destroy();\r\n//       }\r\n//     };\r\n//   }, [trades]);\r\n//   useEffect(() => {\r\n//     if (!loading) {\r\n//       const myChart = updateChart(); // Update chart when trade data or loading state changes\r\n//       return () => {\r\n//         if (myChart) {\r\n//           myChart.destroy(); // Destroy chart instance when component unmounts\r\n//         }\r\n//       };\r\n//     }\r\n//   }, [loading, trades]);\r\n\r\n//   return (\r\n//     <div className=\"account-graph\">\r\n//       {loading ? <p>Loading...</p> : <canvas ref={chartRef} />}\r\n//     </div>\r\n//   );\r\n// };\r\n\r\n// export default AccountGraph;\r\n// // // import React, { useEffect, useRef } from \"react\";\r\n// // // import \"./styles/accountGraph.css\";\r\n\r\n// // // const AccountGraph = ({ trades, onTimePeriodChange }) => {\r\n// // //   const chartRef = useRef(null);\r\n\r\n// // //   useEffect(() => {\r\n// // //     const calculateProfitsForAllTimePeriods = (trades) => {\r\n// // //       const timePeriods = [\"1D\", \"1W\", \"1M\", \"3M\", \"YTD\", \"1Y\", \"Max\"];\r\n// // //       const profitsData = [];\r\n\r\n// // //       timePeriods.forEach((selectedTimePeriod) => {\r\n// // //         let startDate = new Date();\r\n// // //         let totalProfit = 0;\r\n\r\n// // //         switch (selectedTimePeriod) {\r\n// // //           case \"1D\":\r\n// // //             startDate.setDate(startDate.getDate() - 1);\r\n// // //             break;\r\n// // //           case \"1W\":\r\n// // //             startDate.setDate(startDate.getDate() - 7);\r\n// // //             break;\r\n// // //           case \"1M\":\r\n// // //             startDate.setMonth(startDate.getMonth() - 1);\r\n// // //             break;\r\n// // //           case \"3M\":\r\n// // //             startDate.setMonth(startDate.getMonth() - 3);\r\n// // //             break;\r\n// // //           case \"YTD\":\r\n// // //             startDate = new Date(startDate.getFullYear(), 0, 1); // Year to Date\r\n// // //             break;\r\n// // //           case \"1Y\":\r\n// // //             startDate.setFullYear(startDate.getFullYear() - 1);\r\n// // //             break;\r\n// // //           case \"Max\":\r\n// // //             break;\r\n// // //           default:\r\n// // //             break;\r\n// // //         }\r\n\r\n// // //         if (selectedTimePeriod !== \"Max\") {\r\n// // //           const filteredTrades = trades.filter(\r\n// // //             (trade) => new Date(trade.close_date) >= startDate\r\n// // //           );\r\n\r\n// // //           totalProfit = filteredTrades.reduce((sum, trade) => {\r\n// // //             const entryPrice = parseFloat(trade.entry_price);\r\n// // //             const exitPrice = parseFloat(trade.exit_price);\r\n// // //             const contracts = trade.contracts;\r\n// // //             if (!isNaN(exitPrice)) {\r\n// // //               return sum + (exitPrice - entryPrice) * contracts * 100;\r\n// // //             }\r\n// // //             return sum;\r\n// // //           }, 0);\r\n// // //         } else {\r\n// // //           totalProfit = trades.reduce((sum, trade) => {\r\n// // //             const entryPrice = parseFloat(trade.entry_price);\r\n// // //             const exitPrice = parseFloat(trade.exit_price);\r\n// // //             const contracts = trade.contracts;\r\n// // //             if (!isNaN(exitPrice)) {\r\n// // //               return sum + (exitPrice - entryPrice) * contracts * 100;\r\n// // //             }\r\n// // //             return sum;\r\n// // //           }, 0);\r\n// // //         }\r\n\r\n// // //         profitsData.push({\r\n// // //           timePeriod: selectedTimePeriod,\r\n// // //           profit: totalProfit,\r\n// // //           backgroundColor: totalProfit >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\",\r\n// // //         });\r\n// // //       });\r\n\r\n// // //       return profitsData;\r\n// // //     };\r\n\r\n// // //     const ctx = chartRef.current.getContext(\"2d\");\r\n// // //     const profitsData = calculateProfitsForAllTimePeriods(trades);\r\n\r\n// // //     const myChart = new window.Chart(ctx, {\r\n// // //       type: \"bar\",\r\n// // //       data: {\r\n// // //         labels: profitsData.map((data) => data.timePeriod),\r\n// // //         datasets: [\r\n// // //           {\r\n// // //             label: \"Profit/Loss\",\r\n// // //             data: profitsData.map((data) => data.profit),\r\n// // //             backgroundColor: profitsData.map((data) => data.backgroundColor),\r\n// // //             barThickness: 40, // Adjust thickness as needed\r\n// // //           },\r\n// // //         ],\r\n// // //       },\r\n// // //       options: {\r\n// // //         plugins: {\r\n// // //           legend: {\r\n// // //             display: false,\r\n// // //           },\r\n// // //         },\r\n// // //         scales: {\r\n// // //           x: {\r\n// // //             grid: {\r\n// // //               display: false,\r\n// // //             },\r\n// // //           },\r\n// // //           y: {\r\n// // //             display: true,\r\n// // //             title: {\r\n// // //               display: true,\r\n// // //               text: \"Profit/Loss\",\r\n// // //             },\r\n// // //             grid: {\r\n// // //               color: (context) =>\r\n// // //                 context.tick.value === 0\r\n// // //                   ? \"rgba(0, 0, 0, 1)\"\r\n// // //                   : \"rgba(0, 0, 0, 0)\", // Only show line at 0\r\n// // //               lineWidth: 0.5, // Adjust line width as needed\r\n// // //             },\r\n// // //             ticks: {\r\n// // //               callback: function (value, index, values) {\r\n// // //                 return value === 0 ? value : \"\";\r\n// // //               },\r\n// // //             },\r\n// // //           },\r\n// // //         },\r\n// // //       },\r\n// // //     });\r\n\r\n// // //     return () => {\r\n// // //       myChart.destroy();\r\n// // //     };\r\n// // //   }, [trades]);\r\n\r\n// // //   return (\r\n// // //     <div className=\"account-graph\">\r\n// // //       <canvas ref={chartRef} />\r\n// // //     </div>\r\n// // //   );\r\n// // // };\r\n\r\n// // // export default AccountGraph;\r\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA"},"metadata":{},"sourceType":"module"}