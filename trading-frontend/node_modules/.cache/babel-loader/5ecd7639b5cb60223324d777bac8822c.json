{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\casan\\\\trading-app\\\\trading-frontend\\\\src\\\\components\\\\AccountGraph.js\";\nimport React, { useEffect, useRef, useState } from \"react\";\nimport \"./styles/accountGraph.css\";\nimport { fetchTrades } from \"./ApiCalls\"; // Importing fetchTrades function\n\nconst AccountGraph = ({}) => {\n  const chartRef = useRef(null);\n  const [loading, setLoading] = useState(true);\n  const [trades, setTrades] = useState([]);\n  useEffect(() => {\n    const calculateProfitsForAllTimePeriods = tradesData => {\n      const timePeriods = [\"1D\", \"1W\", \"1M\", \"3M\", \"YTD\", \"1Y\", \"Max\"];\n      const profitsData = [];\n      timePeriods.forEach(selectedTimePeriod => {\n        let startDate = new Date();\n        let totalProfit = 0;\n        switch (selectedTimePeriod) {\n          case \"1D\":\n            startDate.setDate(startDate.getDate() - 1);\n            break;\n          case \"1W\":\n            startDate.setDate(startDate.getDate() - 7);\n            break;\n          case \"1M\":\n            startDate.setMonth(startDate.getMonth() - 1);\n            break;\n          case \"3M\":\n            startDate.setMonth(startDate.getMonth() - 3);\n            break;\n          case \"YTD\":\n            startDate = new Date(startDate.getFullYear(), 0, 1); // Year to Date\n            break;\n          case \"1Y\":\n            startDate.setFullYear(startDate.getFullYear() - 1);\n            break;\n          case \"Max\":\n            break;\n          default:\n            break;\n        }\n        if (selectedTimePeriod !== \"Max\") {\n          const filteredTrades = trades.filter(trade => new Date(trade.close_date) >= startDate);\n          totalProfit = filteredTrades.reduce((sum, trade) => {\n            const entryPrice = parseFloat(trade.entry_price);\n            const exitPrice = parseFloat(trade.exit_price);\n            const contracts = trade.contracts;\n            if (!isNaN(exitPrice)) {\n              return sum + (exitPrice - entryPrice) * contracts * 100;\n            }\n            return sum;\n          }, 0);\n        } else {\n          totalProfit = trades.reduce((sum, trade) => {\n            const entryPrice = parseFloat(trade.entry_price);\n            const exitPrice = parseFloat(trade.exit_price);\n            const contracts = trade.contracts;\n            if (!isNaN(exitPrice)) {\n              return sum + (exitPrice - entryPrice) * contracts * 100;\n            }\n            return sum;\n          }, 0);\n        }\n        profitsData.push({\n          timePeriod: selectedTimePeriod,\n          profit: totalProfit,\n          backgroundColor: totalProfit >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\"\n        });\n      });\n      return profitsData;\n    };\n    const updateChart = () => {\n      const ctx = chartRef.current.getContext(\"2d\");\n      const calculatedProfitsData = calculateProfitsForAllTimePeriods(trades);\n      const myChart = new window.Chart(ctx, {\n        type: \"bar\",\n        data: {\n          labels: calculatedProfitsData.map(data => data.timePeriod),\n          datasets: [{\n            label: \"Profit/Loss\",\n            data: calculatedProfitsData.map(data => data.profit),\n            backgroundColor: calculatedProfitsData.map(data => data.backgroundColor),\n            barThickness: 40 // Adjust thickness as needed\n          }]\n        },\n        options: {\n          plugins: {\n            legend: {\n              display: false\n            }\n          },\n          scales: {\n            x: {\n              grid: {\n                display: false\n              }\n            },\n            y: {\n              display: true,\n              title: {\n                display: true,\n                text: \"Profit/Loss\"\n              },\n              grid: {\n                color: context => context.tick.value === 0 ? \"rgba(0, 0, 0, 1)\" : \"rgba(0, 0, 0, 0)\",\n                // Only show line at 0\n                lineWidth: 0.5 // Adjust line width as needed\n              },\n              ticks: {\n                callback: function (value, index, values) {\n                  return value === 0 ? value : \"\";\n                }\n              }\n            }\n          }\n        }\n      });\n      return myChart;\n    };\n    const fetchData = async () => {\n      try {\n        const fetchedTrades = await fetchTrades(); // Fetch trade data\n        setTrades(fetchedTrades); // Set fetched trade data\n        setLoading(false); // Set loading state to false\n      } catch (error) {\n        console.error(\"Error fetching trades:\", error);\n        setLoading(false); // Handle loading state in case of error\n      }\n    };\n    fetchData(); // Fetch trade data when component mounts\n\n    let myChart = updateChart();\n    setLoading(false);\n    return () => {\n      if (myChart) {\n        myChart.destroy();\n      }\n    };\n  }, [trades]);\n  useEffect(() => {\n    // Update chart whenever trades data changes\n    const profitsData = calculateProfitsForAllTimePeriods(trades);\n    updateChart(profitsData);\n  }, [trades]); // Update chart when trades data changes\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"account-graph\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 167,\n      columnNumber: 5\n    }\n  }, loading ? /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 168,\n      columnNumber: 18\n    }\n  }, \"Loading...\") : /*#__PURE__*/React.createElement(\"canvas\", {\n    ref: chartRef,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 168,\n      columnNumber: 38\n    }\n  }));\n};\nexport default AccountGraph;\n\n// // import React, { useEffect, useRef } from \"react\";\n// // import \"./styles/accountGraph.css\";\n\n// // const AccountGraph = ({ trades, onTimePeriodChange }) => {\n// //   const chartRef = useRef(null);\n\n// //   useEffect(() => {\n// //     const calculateProfitsForAllTimePeriods = (trades) => {\n// //       const timePeriods = [\"1D\", \"1W\", \"1M\", \"3M\", \"YTD\", \"1Y\", \"Max\"];\n// //       const profitsData = [];\n\n// //       timePeriods.forEach((selectedTimePeriod) => {\n// //         let startDate = new Date();\n// //         let totalProfit = 0;\n\n// //         switch (selectedTimePeriod) {\n// //           case \"1D\":\n// //             startDate.setDate(startDate.getDate() - 1);\n// //             break;\n// //           case \"1W\":\n// //             startDate.setDate(startDate.getDate() - 7);\n// //             break;\n// //           case \"1M\":\n// //             startDate.setMonth(startDate.getMonth() - 1);\n// //             break;\n// //           case \"3M\":\n// //             startDate.setMonth(startDate.getMonth() - 3);\n// //             break;\n// //           case \"YTD\":\n// //             startDate = new Date(startDate.getFullYear(), 0, 1); // Year to Date\n// //             break;\n// //           case \"1Y\":\n// //             startDate.setFullYear(startDate.getFullYear() - 1);\n// //             break;\n// //           case \"Max\":\n// //             break;\n// //           default:\n// //             break;\n// //         }\n\n// //         if (selectedTimePeriod !== \"Max\") {\n// //           const filteredTrades = trades.filter(\n// //             (trade) => new Date(trade.close_date) >= startDate\n// //           );\n\n// //           totalProfit = filteredTrades.reduce((sum, trade) => {\n// //             const entryPrice = parseFloat(trade.entry_price);\n// //             const exitPrice = parseFloat(trade.exit_price);\n// //             const contracts = trade.contracts;\n// //             if (!isNaN(exitPrice)) {\n// //               return sum + (exitPrice - entryPrice) * contracts * 100;\n// //             }\n// //             return sum;\n// //           }, 0);\n// //         } else {\n// //           totalProfit = trades.reduce((sum, trade) => {\n// //             const entryPrice = parseFloat(trade.entry_price);\n// //             const exitPrice = parseFloat(trade.exit_price);\n// //             const contracts = trade.contracts;\n// //             if (!isNaN(exitPrice)) {\n// //               return sum + (exitPrice - entryPrice) * contracts * 100;\n// //             }\n// //             return sum;\n// //           }, 0);\n// //         }\n\n// //         profitsData.push({\n// //           timePeriod: selectedTimePeriod,\n// //           profit: totalProfit,\n// //           backgroundColor: totalProfit >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\",\n// //         });\n// //       });\n\n// //       return profitsData;\n// //     };\n\n// //     const ctx = chartRef.current.getContext(\"2d\");\n// //     const profitsData = calculateProfitsForAllTimePeriods(trades);\n\n// //     const myChart = new window.Chart(ctx, {\n// //       type: \"bar\",\n// //       data: {\n// //         labels: profitsData.map((data) => data.timePeriod),\n// //         datasets: [\n// //           {\n// //             label: \"Profit/Loss\",\n// //             data: profitsData.map((data) => data.profit),\n// //             backgroundColor: profitsData.map((data) => data.backgroundColor),\n// //             barThickness: 40, // Adjust thickness as needed\n// //           },\n// //         ],\n// //       },\n// //       options: {\n// //         plugins: {\n// //           legend: {\n// //             display: false,\n// //           },\n// //         },\n// //         scales: {\n// //           x: {\n// //             grid: {\n// //               display: false,\n// //             },\n// //           },\n// //           y: {\n// //             display: true,\n// //             title: {\n// //               display: true,\n// //               text: \"Profit/Loss\",\n// //             },\n// //             grid: {\n// //               color: (context) =>\n// //                 context.tick.value === 0\n// //                   ? \"rgba(0, 0, 0, 1)\"\n// //                   : \"rgba(0, 0, 0, 0)\", // Only show line at 0\n// //               lineWidth: 0.5, // Adjust line width as needed\n// //             },\n// //             ticks: {\n// //               callback: function (value, index, values) {\n// //                 return value === 0 ? value : \"\";\n// //               },\n// //             },\n// //           },\n// //         },\n// //       },\n// //     });\n\n// //     return () => {\n// //       myChart.destroy();\n// //     };\n// //   }, [trades]);\n\n// //   return (\n// //     <div className=\"account-graph\">\n// //       <canvas ref={chartRef} />\n// //     </div>\n// //   );\n// // };\n\n// // export default AccountGraph;","map":{"version":3,"names":["React","useEffect","useRef","useState","fetchTrades","AccountGraph","chartRef","loading","setLoading","trades","setTrades","calculateProfitsForAllTimePeriods","tradesData","timePeriods","profitsData","forEach","selectedTimePeriod","startDate","Date","totalProfit","setDate","getDate","setMonth","getMonth","getFullYear","setFullYear","filteredTrades","filter","trade","close_date","reduce","sum","entryPrice","parseFloat","entry_price","exitPrice","exit_price","contracts","isNaN","push","timePeriod","profit","backgroundColor","updateChart","ctx","current","getContext","calculatedProfitsData","myChart","window","Chart","type","data","labels","map","datasets","label","barThickness","options","plugins","legend","display","scales","x","grid","y","title","text","color","context","tick","value","lineWidth","ticks","callback","index","values","fetchData","fetchedTrades","error","console","destroy","createElement","className","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","ref"],"sources":["C:/Users/casan/trading-app/trading-frontend/src/components/AccountGraph.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\r\nimport \"./styles/accountGraph.css\";\r\nimport { fetchTrades } from \"./ApiCalls\"; // Importing fetchTrades function\r\n\r\nconst AccountGraph = ({}) => {\r\n  const chartRef = useRef(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [trades, setTrades] = useState([]);\r\n\r\n  useEffect(() => {\r\n    const calculateProfitsForAllTimePeriods = (tradesData) => {\r\n      const timePeriods = [\"1D\", \"1W\", \"1M\", \"3M\", \"YTD\", \"1Y\", \"Max\"];\r\n      const profitsData = [];\r\n\r\n      timePeriods.forEach((selectedTimePeriod) => {\r\n        let startDate = new Date();\r\n        let totalProfit = 0;\r\n\r\n        switch (selectedTimePeriod) {\r\n          case \"1D\":\r\n            startDate.setDate(startDate.getDate() - 1);\r\n            break;\r\n          case \"1W\":\r\n            startDate.setDate(startDate.getDate() - 7);\r\n            break;\r\n          case \"1M\":\r\n            startDate.setMonth(startDate.getMonth() - 1);\r\n            break;\r\n          case \"3M\":\r\n            startDate.setMonth(startDate.getMonth() - 3);\r\n            break;\r\n          case \"YTD\":\r\n            startDate = new Date(startDate.getFullYear(), 0, 1); // Year to Date\r\n            break;\r\n          case \"1Y\":\r\n            startDate.setFullYear(startDate.getFullYear() - 1);\r\n            break;\r\n          case \"Max\":\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n\r\n        if (selectedTimePeriod !== \"Max\") {\r\n          const filteredTrades = trades.filter(\r\n            (trade) => new Date(trade.close_date) >= startDate\r\n          );\r\n\r\n          totalProfit = filteredTrades.reduce((sum, trade) => {\r\n            const entryPrice = parseFloat(trade.entry_price);\r\n            const exitPrice = parseFloat(trade.exit_price);\r\n            const contracts = trade.contracts;\r\n            if (!isNaN(exitPrice)) {\r\n              return sum + (exitPrice - entryPrice) * contracts * 100;\r\n            }\r\n            return sum;\r\n          }, 0);\r\n        } else {\r\n          totalProfit = trades.reduce((sum, trade) => {\r\n            const entryPrice = parseFloat(trade.entry_price);\r\n            const exitPrice = parseFloat(trade.exit_price);\r\n            const contracts = trade.contracts;\r\n            if (!isNaN(exitPrice)) {\r\n              return sum + (exitPrice - entryPrice) * contracts * 100;\r\n            }\r\n            return sum;\r\n          }, 0);\r\n        }\r\n\r\n        profitsData.push({\r\n          timePeriod: selectedTimePeriod,\r\n          profit: totalProfit,\r\n          backgroundColor: totalProfit >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\",\r\n        });\r\n      });\r\n\r\n      return profitsData;\r\n    };\r\n\r\n    const updateChart = () => {\r\n      const ctx = chartRef.current.getContext(\"2d\");\r\n      const calculatedProfitsData = calculateProfitsForAllTimePeriods(trades);\r\n\r\n      const myChart = new window.Chart(ctx, {\r\n        type: \"bar\",\r\n        data: {\r\n          labels: calculatedProfitsData.map((data) => data.timePeriod),\r\n          datasets: [\r\n            {\r\n              label: \"Profit/Loss\",\r\n              data: calculatedProfitsData.map((data) => data.profit),\r\n              backgroundColor: calculatedProfitsData.map(\r\n                (data) => data.backgroundColor\r\n              ),\r\n              barThickness: 40, // Adjust thickness as needed\r\n            },\r\n          ],\r\n        },\r\n        options: {\r\n          plugins: {\r\n            legend: {\r\n              display: false,\r\n            },\r\n          },\r\n          scales: {\r\n            x: {\r\n              grid: {\r\n                display: false,\r\n              },\r\n            },\r\n            y: {\r\n              display: true,\r\n              title: {\r\n                display: true,\r\n                text: \"Profit/Loss\",\r\n              },\r\n              grid: {\r\n                color: (context) =>\r\n                  context.tick.value === 0\r\n                    ? \"rgba(0, 0, 0, 1)\"\r\n                    : \"rgba(0, 0, 0, 0)\", // Only show line at 0\r\n                lineWidth: 0.5, // Adjust line width as needed\r\n              },\r\n              ticks: {\r\n                callback: function (value, index, values) {\r\n                  return value === 0 ? value : \"\";\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      return myChart;\r\n    };\r\n\r\n    const fetchData = async () => {\r\n      try {\r\n        const fetchedTrades = await fetchTrades(); // Fetch trade data\r\n        setTrades(fetchedTrades); // Set fetched trade data\r\n        setLoading(false); // Set loading state to false\r\n      } catch (error) {\r\n        console.error(\"Error fetching trades:\", error);\r\n        setLoading(false); // Handle loading state in case of error\r\n      }\r\n    };\r\n\r\n    fetchData(); // Fetch trade data when component mounts\r\n\r\n    let myChart = updateChart();\r\n    setLoading(false);\r\n\r\n    return () => {\r\n      if (myChart) {\r\n        myChart.destroy();\r\n      }\r\n    };\r\n  }, [trades]);\r\n\r\n  useEffect(() => {\r\n    // Update chart whenever trades data changes\r\n    const profitsData = calculateProfitsForAllTimePeriods(trades);\r\n    updateChart(profitsData);\r\n  }, [trades]); // Update chart when trades data changes\r\n\r\n  return (\r\n    <div className=\"account-graph\">\r\n      {loading ? <p>Loading...</p> : <canvas ref={chartRef} />}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default AccountGraph;\r\n\r\n// // import React, { useEffect, useRef } from \"react\";\r\n// // import \"./styles/accountGraph.css\";\r\n\r\n// // const AccountGraph = ({ trades, onTimePeriodChange }) => {\r\n// //   const chartRef = useRef(null);\r\n\r\n// //   useEffect(() => {\r\n// //     const calculateProfitsForAllTimePeriods = (trades) => {\r\n// //       const timePeriods = [\"1D\", \"1W\", \"1M\", \"3M\", \"YTD\", \"1Y\", \"Max\"];\r\n// //       const profitsData = [];\r\n\r\n// //       timePeriods.forEach((selectedTimePeriod) => {\r\n// //         let startDate = new Date();\r\n// //         let totalProfit = 0;\r\n\r\n// //         switch (selectedTimePeriod) {\r\n// //           case \"1D\":\r\n// //             startDate.setDate(startDate.getDate() - 1);\r\n// //             break;\r\n// //           case \"1W\":\r\n// //             startDate.setDate(startDate.getDate() - 7);\r\n// //             break;\r\n// //           case \"1M\":\r\n// //             startDate.setMonth(startDate.getMonth() - 1);\r\n// //             break;\r\n// //           case \"3M\":\r\n// //             startDate.setMonth(startDate.getMonth() - 3);\r\n// //             break;\r\n// //           case \"YTD\":\r\n// //             startDate = new Date(startDate.getFullYear(), 0, 1); // Year to Date\r\n// //             break;\r\n// //           case \"1Y\":\r\n// //             startDate.setFullYear(startDate.getFullYear() - 1);\r\n// //             break;\r\n// //           case \"Max\":\r\n// //             break;\r\n// //           default:\r\n// //             break;\r\n// //         }\r\n\r\n// //         if (selectedTimePeriod !== \"Max\") {\r\n// //           const filteredTrades = trades.filter(\r\n// //             (trade) => new Date(trade.close_date) >= startDate\r\n// //           );\r\n\r\n// //           totalProfit = filteredTrades.reduce((sum, trade) => {\r\n// //             const entryPrice = parseFloat(trade.entry_price);\r\n// //             const exitPrice = parseFloat(trade.exit_price);\r\n// //             const contracts = trade.contracts;\r\n// //             if (!isNaN(exitPrice)) {\r\n// //               return sum + (exitPrice - entryPrice) * contracts * 100;\r\n// //             }\r\n// //             return sum;\r\n// //           }, 0);\r\n// //         } else {\r\n// //           totalProfit = trades.reduce((sum, trade) => {\r\n// //             const entryPrice = parseFloat(trade.entry_price);\r\n// //             const exitPrice = parseFloat(trade.exit_price);\r\n// //             const contracts = trade.contracts;\r\n// //             if (!isNaN(exitPrice)) {\r\n// //               return sum + (exitPrice - entryPrice) * contracts * 100;\r\n// //             }\r\n// //             return sum;\r\n// //           }, 0);\r\n// //         }\r\n\r\n// //         profitsData.push({\r\n// //           timePeriod: selectedTimePeriod,\r\n// //           profit: totalProfit,\r\n// //           backgroundColor: totalProfit >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\",\r\n// //         });\r\n// //       });\r\n\r\n// //       return profitsData;\r\n// //     };\r\n\r\n// //     const ctx = chartRef.current.getContext(\"2d\");\r\n// //     const profitsData = calculateProfitsForAllTimePeriods(trades);\r\n\r\n// //     const myChart = new window.Chart(ctx, {\r\n// //       type: \"bar\",\r\n// //       data: {\r\n// //         labels: profitsData.map((data) => data.timePeriod),\r\n// //         datasets: [\r\n// //           {\r\n// //             label: \"Profit/Loss\",\r\n// //             data: profitsData.map((data) => data.profit),\r\n// //             backgroundColor: profitsData.map((data) => data.backgroundColor),\r\n// //             barThickness: 40, // Adjust thickness as needed\r\n// //           },\r\n// //         ],\r\n// //       },\r\n// //       options: {\r\n// //         plugins: {\r\n// //           legend: {\r\n// //             display: false,\r\n// //           },\r\n// //         },\r\n// //         scales: {\r\n// //           x: {\r\n// //             grid: {\r\n// //               display: false,\r\n// //             },\r\n// //           },\r\n// //           y: {\r\n// //             display: true,\r\n// //             title: {\r\n// //               display: true,\r\n// //               text: \"Profit/Loss\",\r\n// //             },\r\n// //             grid: {\r\n// //               color: (context) =>\r\n// //                 context.tick.value === 0\r\n// //                   ? \"rgba(0, 0, 0, 1)\"\r\n// //                   : \"rgba(0, 0, 0, 0)\", // Only show line at 0\r\n// //               lineWidth: 0.5, // Adjust line width as needed\r\n// //             },\r\n// //             ticks: {\r\n// //               callback: function (value, index, values) {\r\n// //                 return value === 0 ? value : \"\";\r\n// //               },\r\n// //             },\r\n// //           },\r\n// //         },\r\n// //       },\r\n// //     });\r\n\r\n// //     return () => {\r\n// //       myChart.destroy();\r\n// //     };\r\n// //   }, [trades]);\r\n\r\n// //   return (\r\n// //     <div className=\"account-graph\">\r\n// //       <canvas ref={chartRef} />\r\n// //     </div>\r\n// //   );\r\n// // };\r\n\r\n// // export default AccountGraph;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}