{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\casan\\\\trading-app\\\\trading-frontend\\\\src\\\\components\\\\Graph.js\";\nimport React, { useEffect, useRef, useState } from \"react\";\nimport Chart from \"chart.js\";\nconst Graph = () => {\n  const chartRef = useRef(null);\n  const [loading, setLoading] = useState(true);\n  const [profits, setProfits] = useState({});\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(\"http://localhost:8000/Graph/\");\n        if (!response.ok) {\n          throw new Error(\"Failed to fetch data\");\n        }\n        const data = await response.json();\n        setProfits(data);\n        setLoading(false);\n      } catch (error) {\n        console.error(\"Error fetching data:\", error);\n        setLoading(false);\n      }\n    };\n    fetchData();\n  }, []);\n  useEffect(() => {\n    if (!loading) {\n      renderChart();\n    }\n  }, [loading, profits]);\n  const renderChart = () => {\n    const labels = Object.keys(profits);\n    const data = Object.values(profits);\n    const ctx = chartRef.current.getContext(\"2d\");\n    new Chart(ctx, {\n      type: \"bar\",\n      data: {\n        labels: labels,\n        datasets: [{\n          label: \"Profit/Loss\",\n          data: data,\n          backgroundColor: data.map(value => value >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\"),\n          barThickness: 40\n        }]\n      },\n      options: {\n        plugins: {\n          legend: {\n            display: false\n          }\n        },\n        scales: {\n          x: {\n            grid: {\n              display: false\n            }\n          },\n          y: {\n            display: true,\n            title: {\n              display: true,\n              text: \"Profit/Loss\"\n            },\n            grid: {\n              color: context => context.tick.value === 0 ? \"rgba(0, 0, 0, 1)\" : \"rgba(0, 0, 0, 0)\",\n              lineWidth: 0.5\n            },\n            ticks: {\n              callback: function (value, index, values) {\n                return value === 0 ? value : \"\";\n              }\n            }\n          }\n        }\n      }\n    });\n  };\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"graph\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 91,\n      columnNumber: 5\n    }\n  }, loading ? /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 92,\n      columnNumber: 18\n    }\n  }, \"Loading...\") : /*#__PURE__*/React.createElement(\"canvas\", {\n    ref: chartRef,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 92,\n      columnNumber: 38\n    }\n  }));\n};\nexport default Graph;\n\n// import React, { useEffect, useRef, useState } from \"react\";\n// import { fetchTrades } from \"./ApiCalls\"; // Assuming fetchTrades is a function that fetches trades from the backend\n\n// const Graph = () => {\n//   const chartRef = useRef(null);\n//   const [loading, setLoading] = useState(true);\n//   const [trades, setTrades] = useState([]);\n//   const [profits, setProfits] = useState({});\n\n//   const calculateProfitsForAllTimePeriods = (trades) => {\n//     const timePeriods = [\"1D\", \"1W\", \"1M\", \"3M\", \"YTD\", \"1Y\", \"Max\"];\n//     const profitsData = {};\n//     const now = new Date();\n\n//     const startDates = {\n//       \"1D\": new Date(now.setDate(now.getDate() - 1)),\n//       \"1W\": new Date(now.setDate(now.getDate() - 7)),\n//       \"1M\": new Date(now.setMonth(now.getMonth() - 1)),\n//       \"3M\": new Date(now.setMonth(now.getMonth() - 3)),\n//       YTD: new Date(now.getFullYear(), 0, 1),\n//       \"1Y\": new Date(now.setFullYear(now.getFullYear() - 1)),\n//       Max: new Date(0),\n//     };\n\n//     for (const period of timePeriods) {\n//       const startDate = startDates[period];\n//       const filteredTrades = trades.filter(\n//         (trade) => new Date(trade.close_date) >= startDate\n//       );\n\n//       const totalProfit = filteredTrades.reduce((sum, trade) => {\n//         const entryPrice = parseFloat(trade.entry_price);\n//         const exitPrice = parseFloat(trade.exit_price);\n//         const contracts = trade.contracts;\n//         if (!isNaN(exitPrice)) {\n//           return sum + (exitPrice - entryPrice) * contracts * 100;\n//         }\n//         return sum;\n//       }, 0);\n\n//       profitsData[period] = totalProfit;\n//     }\n\n//     return profitsData;\n//   };\n\n//   useEffect(() => {\n//     const fetchData = async () => {\n//       try {\n//         const fetchedTrades = await fetchTrades(); // Fetch trade data from the backend\n//         setTrades(fetchedTrades); // Set fetched trade data\n//         const calculatedProfits =\n//           calculateProfitsForAllTimePeriods(fetchedTrades);\n//         setProfits(calculatedProfits);\n//         setLoading(false); // Set loading state to false\n//       } catch (error) {\n//         console.error(\"Error fetching trades:\", error);\n//       }\n//     };\n\n//     fetchData(); // Fetch trade data when component mounts\n//   }, []);\n\n//   useEffect(() => {\n//     if (!loading && trades.length > 0) {\n//       const ctx = chartRef.current.getContext(\"2d\");\n//       const profitValues = Object.values(profits);\n//       const backgroundColors = profitValues.map((value) =>\n//         value >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\"\n//       );\n\n//       const myChart = new window.Chart(ctx, {\n//         type: \"bar\",\n//         data: {\n//           labels: Object.keys(profits),\n//           datasets: [\n//             {\n//               label: \"Profit/Loss\",\n//               data: profitValues,\n//               backgroundColor: backgroundColors,\n//               barThickness: 40,\n//             },\n//           ],\n//         },\n//         options: {\n//           plugins: {\n//             legend: {\n//               display: false,\n//             },\n//           },\n//           scales: {\n//             x: {\n//               grid: {\n//                 display: false,\n//               },\n//             },\n//             y: {\n//               display: true,\n//               title: {\n//                 display: true,\n//                 text: \"Profit/Loss\",\n//               },\n//               grid: {\n//                 color: (context) =>\n//                   context.tick.value === 0\n//                     ? \"rgba(0, 0, 0, 1)\"\n//                     : \"rgba(0, 0, 0, 0)\",\n//                 lineWidth: 0.5,\n//               },\n//               ticks: {\n//                 callback: function (value, index, values) {\n//                   return value === 0 ? value : \"\";\n//                 },\n//               },\n//             },\n//           },\n//         },\n//       });\n\n//       return () => {\n//         if (myChart) {\n//           myChart.destroy();\n//         }\n//       };\n//     }\n//   }, [loading, trades, profits]);\n\n//   return (\n//     <div className=\"graph\">\n//       {loading ? <p>Loading...</p> : <canvas ref={chartRef} />}\n//     </div>\n//   );\n// };\n\n// export default Graph;","map":{"version":3,"names":["React","useEffect","useRef","useState","Chart","Graph","chartRef","loading","setLoading","profits","setProfits","fetchData","response","fetch","ok","Error","data","json","error","console","renderChart","labels","Object","keys","values","ctx","current","getContext","type","datasets","label","backgroundColor","map","value","barThickness","options","plugins","legend","display","scales","x","grid","y","title","text","color","context","tick","lineWidth","ticks","callback","index","createElement","className","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","ref"],"sources":["C:/Users/casan/trading-app/trading-frontend/src/components/Graph.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\r\nimport Chart from \"chart.js\";\r\n\r\nconst Graph = () => {\r\n  const chartRef = useRef(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [profits, setProfits] = useState({});\r\n\r\n  useEffect(() => {\r\n    const fetchData = async () => {\r\n      try {\r\n        const response = await fetch(\"http://localhost:8000/Graph/\");\r\n        if (!response.ok) {\r\n          throw new Error(\"Failed to fetch data\");\r\n        }\r\n        const data = await response.json();\r\n        setProfits(data);\r\n        setLoading(false);\r\n      } catch (error) {\r\n        console.error(\"Error fetching data:\", error);\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    fetchData();\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (!loading) {\r\n      renderChart();\r\n    }\r\n  }, [loading, profits]);\r\n\r\n  const renderChart = () => {\r\n    const labels = Object.keys(profits);\r\n    const data = Object.values(profits);\r\n\r\n    const ctx = chartRef.current.getContext(\"2d\");\r\n    new Chart(ctx, {\r\n      type: \"bar\",\r\n      data: {\r\n        labels: labels,\r\n        datasets: [\r\n          {\r\n            label: \"Profit/Loss\",\r\n            data: data,\r\n            backgroundColor: data.map((value) =>\r\n              value >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\"\r\n            ),\r\n            barThickness: 40,\r\n          },\r\n        ],\r\n      },\r\n      options: {\r\n        plugins: {\r\n          legend: {\r\n            display: false,\r\n          },\r\n        },\r\n        scales: {\r\n          x: {\r\n            grid: {\r\n              display: false,\r\n            },\r\n          },\r\n          y: {\r\n            display: true,\r\n            title: {\r\n              display: true,\r\n              text: \"Profit/Loss\",\r\n            },\r\n            grid: {\r\n              color: (context) =>\r\n                context.tick.value === 0\r\n                  ? \"rgba(0, 0, 0, 1)\"\r\n                  : \"rgba(0, 0, 0, 0)\",\r\n              lineWidth: 0.5,\r\n            },\r\n            ticks: {\r\n              callback: function (value, index, values) {\r\n                return value === 0 ? value : \"\";\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n  };\r\n\r\n  return (\r\n    <div className=\"graph\">\r\n      {loading ? <p>Loading...</p> : <canvas ref={chartRef} />}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Graph;\r\n\r\n// import React, { useEffect, useRef, useState } from \"react\";\r\n// import { fetchTrades } from \"./ApiCalls\"; // Assuming fetchTrades is a function that fetches trades from the backend\r\n\r\n// const Graph = () => {\r\n//   const chartRef = useRef(null);\r\n//   const [loading, setLoading] = useState(true);\r\n//   const [trades, setTrades] = useState([]);\r\n//   const [profits, setProfits] = useState({});\r\n\r\n//   const calculateProfitsForAllTimePeriods = (trades) => {\r\n//     const timePeriods = [\"1D\", \"1W\", \"1M\", \"3M\", \"YTD\", \"1Y\", \"Max\"];\r\n//     const profitsData = {};\r\n//     const now = new Date();\r\n\r\n//     const startDates = {\r\n//       \"1D\": new Date(now.setDate(now.getDate() - 1)),\r\n//       \"1W\": new Date(now.setDate(now.getDate() - 7)),\r\n//       \"1M\": new Date(now.setMonth(now.getMonth() - 1)),\r\n//       \"3M\": new Date(now.setMonth(now.getMonth() - 3)),\r\n//       YTD: new Date(now.getFullYear(), 0, 1),\r\n//       \"1Y\": new Date(now.setFullYear(now.getFullYear() - 1)),\r\n//       Max: new Date(0),\r\n//     };\r\n\r\n//     for (const period of timePeriods) {\r\n//       const startDate = startDates[period];\r\n//       const filteredTrades = trades.filter(\r\n//         (trade) => new Date(trade.close_date) >= startDate\r\n//       );\r\n\r\n//       const totalProfit = filteredTrades.reduce((sum, trade) => {\r\n//         const entryPrice = parseFloat(trade.entry_price);\r\n//         const exitPrice = parseFloat(trade.exit_price);\r\n//         const contracts = trade.contracts;\r\n//         if (!isNaN(exitPrice)) {\r\n//           return sum + (exitPrice - entryPrice) * contracts * 100;\r\n//         }\r\n//         return sum;\r\n//       }, 0);\r\n\r\n//       profitsData[period] = totalProfit;\r\n//     }\r\n\r\n//     return profitsData;\r\n//   };\r\n\r\n//   useEffect(() => {\r\n//     const fetchData = async () => {\r\n//       try {\r\n//         const fetchedTrades = await fetchTrades(); // Fetch trade data from the backend\r\n//         setTrades(fetchedTrades); // Set fetched trade data\r\n//         const calculatedProfits =\r\n//           calculateProfitsForAllTimePeriods(fetchedTrades);\r\n//         setProfits(calculatedProfits);\r\n//         setLoading(false); // Set loading state to false\r\n//       } catch (error) {\r\n//         console.error(\"Error fetching trades:\", error);\r\n//       }\r\n//     };\r\n\r\n//     fetchData(); // Fetch trade data when component mounts\r\n//   }, []);\r\n\r\n//   useEffect(() => {\r\n//     if (!loading && trades.length > 0) {\r\n//       const ctx = chartRef.current.getContext(\"2d\");\r\n//       const profitValues = Object.values(profits);\r\n//       const backgroundColors = profitValues.map((value) =>\r\n//         value >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\"\r\n//       );\r\n\r\n//       const myChart = new window.Chart(ctx, {\r\n//         type: \"bar\",\r\n//         data: {\r\n//           labels: Object.keys(profits),\r\n//           datasets: [\r\n//             {\r\n//               label: \"Profit/Loss\",\r\n//               data: profitValues,\r\n//               backgroundColor: backgroundColors,\r\n//               barThickness: 40,\r\n//             },\r\n//           ],\r\n//         },\r\n//         options: {\r\n//           plugins: {\r\n//             legend: {\r\n//               display: false,\r\n//             },\r\n//           },\r\n//           scales: {\r\n//             x: {\r\n//               grid: {\r\n//                 display: false,\r\n//               },\r\n//             },\r\n//             y: {\r\n//               display: true,\r\n//               title: {\r\n//                 display: true,\r\n//                 text: \"Profit/Loss\",\r\n//               },\r\n//               grid: {\r\n//                 color: (context) =>\r\n//                   context.tick.value === 0\r\n//                     ? \"rgba(0, 0, 0, 1)\"\r\n//                     : \"rgba(0, 0, 0, 0)\",\r\n//                 lineWidth: 0.5,\r\n//               },\r\n//               ticks: {\r\n//                 callback: function (value, index, values) {\r\n//                   return value === 0 ? value : \"\";\r\n//                 },\r\n//               },\r\n//             },\r\n//           },\r\n//         },\r\n//       });\r\n\r\n//       return () => {\r\n//         if (myChart) {\r\n//           myChart.destroy();\r\n//         }\r\n//       };\r\n//     }\r\n//   }, [loading, trades, profits]);\r\n\r\n//   return (\r\n//     <div className=\"graph\">\r\n//       {loading ? <p>Loading...</p> : <canvas ref={chartRef} />}\r\n//     </div>\r\n//   );\r\n// };\r\n\r\n// export default Graph;\r\n"],"mappings":"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ACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module"}