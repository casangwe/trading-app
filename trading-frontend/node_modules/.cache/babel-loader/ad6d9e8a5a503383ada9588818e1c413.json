{"ast":null,"code":"// import React, { useEffect, useRef, useState } from \"react\";\n// import \"./styles/accountGraph.css\";\n\n// const AccountGraph = ({ trades }) => {\n//   const chartRef = useRef(null);\n//   const [loading, setLoading] = useState(true);\n\n//   useEffect(() => {\n//     const calculateProfitsForAllTimePeriods = (trades) => {\n//       const timePeriods = [\"1D\", \"1W\", \"1M\", \"3M\", \"YTD\", \"1Y\", \"Max\"];\n//       const profitsData = [];\n\n//       timePeriods.forEach((selectedTimePeriod) => {\n//         let startDate = new Date();\n//         let totalProfit = 0;\n\n//         switch (selectedTimePeriod) {\n//           case \"1D\":\n//             startDate.setDate(startDate.getDate() - 1);\n//             break;\n//           case \"1W\":\n//             startDate.setDate(startDate.getDate() - 7);\n//             break;\n//           case \"1M\":\n//             startDate.setMonth(startDate.getMonth() - 1);\n//             break;\n//           case \"3M\":\n//             startDate.setMonth(startDate.getMonth() - 3);\n//             break;\n//           case \"YTD\":\n//             startDate = new Date(startDate.getFullYear(), 0, 1); // Year to Date\n//             break;\n//           case \"1Y\":\n//             startDate.setFullYear(startDate.getFullYear() - 1);\n//             break;\n//           case \"Max\":\n//             break;\n//           default:\n//             break;\n//         }\n\n//         if (selectedTimePeriod !== \"Max\") {\n//           const filteredTrades = trades.filter(\n//             (trade) => new Date(trade.close_date) >= startDate\n//           );\n\n//           totalProfit = filteredTrades.reduce((sum, trade) => {\n//             const entryPrice = parseFloat(trade.entry_price);\n//             const exitPrice = parseFloat(trade.exit_price);\n//             const contracts = trade.contracts;\n//             if (!isNaN(exitPrice)) {\n//               return sum + (exitPrice - entryPrice) * contracts * 100;\n//             }\n//             return sum;\n//           }, 0);\n//         } else {\n//           totalProfit = trades.reduce((sum, trade) => {\n//             const entryPrice = parseFloat(trade.entry_price);\n//             const exitPrice = parseFloat(trade.exit_price);\n//             const contracts = trade.contracts;\n//             if (!isNaN(exitPrice)) {\n//               return sum + (exitPrice - entryPrice) * contracts * 100;\n//             }\n//             return sum;\n//           }, 0);\n//         }\n\n//         profitsData.push({\n//           timePeriod: selectedTimePeriod,\n//           profit: totalProfit,\n//           backgroundColor: totalProfit >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\",\n//         });\n//       });\n\n//       return profitsData;\n//     };\n\n//     const updateChart = () => {\n//       const ctx = chartRef.current.getContext(\"2d\");\n//       const profitsData = calculateProfitsForAllTimePeriods(trades);\n\n//       const myChart = new window.Chart(ctx, {\n//         type: \"bar\",\n//         data: {\n//           labels: profitsData.map((data) => data.timePeriod),\n//           datasets: [\n//             {\n//               label: \"Profit/Loss\",\n//               data: profitsData.map((data) => data.profit),\n//               backgroundColor: profitsData.map((data) => data.backgroundColor),\n//               barThickness: 40, // Adjust thickness as needed\n//             },\n//           ],\n//         },\n//         options: {\n//           plugins: {\n//             legend: {\n//               display: false,\n//             },\n//           },\n//           scales: {\n//             x: {\n//               grid: {\n//                 display: false,\n//               },\n//             },\n//             y: {\n//               display: true,\n//               title: {\n//                 display: true,\n//                 text: \"Profit/Loss\",\n//               },\n//               grid: {\n//                 color: (context) =>\n//                   context.tick.value === 0\n//                     ? \"rgba(0, 0, 0, 1)\"\n//                     : \"rgba(0, 0, 0, 0)\", // Only show line at 0\n//                 lineWidth: 0.5, // Adjust line width as needed\n//               },\n//               ticks: {\n//                 callback: function (value, index, values) {\n//                   return value === 0 ? value : \"\";\n//                 },\n//               },\n//             },\n//           },\n//         },\n//       });\n\n//       return myChart;\n//     };\n\n//     let myChart = updateChart();\n//     setLoading(false);\n\n//     return () => {\n//       if (myChart) {\n//         myChart.destroy();\n//       }\n//     };\n//   }, [trades]);\n\n//   return (\n//     <div className=\"account-graph\">\n//       {loading ? <p>Loading...</p> : <canvas ref={chartRef} />}\n//     </div>\n//   );\n// };\n\n// export default AccountGraph;\n\n// // import React, { useEffect, useRef } from \"react\";\n// // import \"./styles/accountGraph.css\";\n\n// // const AccountGraph = ({ trades, onTimePeriodChange }) => {\n// //   const chartRef = useRef(null);\n\n// //   useEffect(() => {\n// //     const calculateProfitsForAllTimePeriods = (trades) => {\n// //       const timePeriods = [\"1D\", \"1W\", \"1M\", \"3M\", \"YTD\", \"1Y\", \"Max\"];\n// //       const profitsData = [];\n\n// //       timePeriods.forEach((selectedTimePeriod) => {\n// //         let startDate = new Date();\n// //         let totalProfit = 0;\n\n// //         switch (selectedTimePeriod) {\n// //           case \"1D\":\n// //             startDate.setDate(startDate.getDate() - 1);\n// //             break;\n// //           case \"1W\":\n// //             startDate.setDate(startDate.getDate() - 7);\n// //             break;\n// //           case \"1M\":\n// //             startDate.setMonth(startDate.getMonth() - 1);\n// //             break;\n// //           case \"3M\":\n// //             startDate.setMonth(startDate.getMonth() - 3);\n// //             break;\n// //           case \"YTD\":\n// //             startDate = new Date(startDate.getFullYear(), 0, 1); // Year to Date\n// //             break;\n// //           case \"1Y\":\n// //             startDate.setFullYear(startDate.getFullYear() - 1);\n// //             break;\n// //           case \"Max\":\n// //             break;\n// //           default:\n// //             break;\n// //         }\n\n// //         if (selectedTimePeriod !== \"Max\") {\n// //           const filteredTrades = trades.filter(\n// //             (trade) => new Date(trade.close_date) >= startDate\n// //           );\n\n// //           totalProfit = filteredTrades.reduce((sum, trade) => {\n// //             const entryPrice = parseFloat(trade.entry_price);\n// //             const exitPrice = parseFloat(trade.exit_price);\n// //             const contracts = trade.contracts;\n// //             if (!isNaN(exitPrice)) {\n// //               return sum + (exitPrice - entryPrice) * contracts * 100;\n// //             }\n// //             return sum;\n// //           }, 0);\n// //         } else {\n// //           totalProfit = trades.reduce((sum, trade) => {\n// //             const entryPrice = parseFloat(trade.entry_price);\n// //             const exitPrice = parseFloat(trade.exit_price);\n// //             const contracts = trade.contracts;\n// //             if (!isNaN(exitPrice)) {\n// //               return sum + (exitPrice - entryPrice) * contracts * 100;\n// //             }\n// //             return sum;\n// //           }, 0);\n// //         }\n\n// //         profitsData.push({\n// //           timePeriod: selectedTimePeriod,\n// //           profit: totalProfit,\n// //           backgroundColor: totalProfit >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\",\n// //         });\n// //       });\n\n// //       return profitsData;\n// //     };\n\n// //     const ctx = chartRef.current.getContext(\"2d\");\n// //     const profitsData = calculateProfitsForAllTimePeriods(trades);\n\n// //     const myChart = new window.Chart(ctx, {\n// //       type: \"bar\",\n// //       data: {\n// //         labels: profitsData.map((data) => data.timePeriod),\n// //         datasets: [\n// //           {\n// //             label: \"Profit/Loss\",\n// //             data: profitsData.map((data) => data.profit),\n// //             backgroundColor: profitsData.map((data) => data.backgroundColor),\n// //             barThickness: 40, // Adjust thickness as needed\n// //           },\n// //         ],\n// //       },\n// //       options: {\n// //         plugins: {\n// //           legend: {\n// //             display: false,\n// //           },\n// //         },\n// //         scales: {\n// //           x: {\n// //             grid: {\n// //               display: false,\n// //             },\n// //           },\n// //           y: {\n// //             display: true,\n// //             title: {\n// //               display: true,\n// //               text: \"Profit/Loss\",\n// //             },\n// //             grid: {\n// //               color: (context) =>\n// //                 context.tick.value === 0\n// //                   ? \"rgba(0, 0, 0, 1)\"\n// //                   : \"rgba(0, 0, 0, 0)\", // Only show line at 0\n// //               lineWidth: 0.5, // Adjust line width as needed\n// //             },\n// //             ticks: {\n// //               callback: function (value, index, values) {\n// //                 return value === 0 ? value : \"\";\n// //               },\n// //             },\n// //           },\n// //         },\n// //       },\n// //     });\n\n// //     return () => {\n// //       myChart.destroy();\n// //     };\n// //   }, [trades]);\n\n// //   return (\n// //     <div className=\"account-graph\">\n// //       <canvas ref={chartRef} />\n// //     </div>\n// //   );\n// // };\n\n// // export default AccountGraph;","map":{"version":3,"names":[],"sources":["C:/Users/casan/trading-app/trading-frontend/src/components/NewTrade.js"],"sourcesContent":["// import React, { useEffect, useRef, useState } from \"react\";\r\n// import \"./styles/accountGraph.css\";\r\n\r\n// const AccountGraph = ({ trades }) => {\r\n//   const chartRef = useRef(null);\r\n//   const [loading, setLoading] = useState(true);\r\n\r\n//   useEffect(() => {\r\n//     const calculateProfitsForAllTimePeriods = (trades) => {\r\n//       const timePeriods = [\"1D\", \"1W\", \"1M\", \"3M\", \"YTD\", \"1Y\", \"Max\"];\r\n//       const profitsData = [];\r\n\r\n//       timePeriods.forEach((selectedTimePeriod) => {\r\n//         let startDate = new Date();\r\n//         let totalProfit = 0;\r\n\r\n//         switch (selectedTimePeriod) {\r\n//           case \"1D\":\r\n//             startDate.setDate(startDate.getDate() - 1);\r\n//             break;\r\n//           case \"1W\":\r\n//             startDate.setDate(startDate.getDate() - 7);\r\n//             break;\r\n//           case \"1M\":\r\n//             startDate.setMonth(startDate.getMonth() - 1);\r\n//             break;\r\n//           case \"3M\":\r\n//             startDate.setMonth(startDate.getMonth() - 3);\r\n//             break;\r\n//           case \"YTD\":\r\n//             startDate = new Date(startDate.getFullYear(), 0, 1); // Year to Date\r\n//             break;\r\n//           case \"1Y\":\r\n//             startDate.setFullYear(startDate.getFullYear() - 1);\r\n//             break;\r\n//           case \"Max\":\r\n//             break;\r\n//           default:\r\n//             break;\r\n//         }\r\n\r\n//         if (selectedTimePeriod !== \"Max\") {\r\n//           const filteredTrades = trades.filter(\r\n//             (trade) => new Date(trade.close_date) >= startDate\r\n//           );\r\n\r\n//           totalProfit = filteredTrades.reduce((sum, trade) => {\r\n//             const entryPrice = parseFloat(trade.entry_price);\r\n//             const exitPrice = parseFloat(trade.exit_price);\r\n//             const contracts = trade.contracts;\r\n//             if (!isNaN(exitPrice)) {\r\n//               return sum + (exitPrice - entryPrice) * contracts * 100;\r\n//             }\r\n//             return sum;\r\n//           }, 0);\r\n//         } else {\r\n//           totalProfit = trades.reduce((sum, trade) => {\r\n//             const entryPrice = parseFloat(trade.entry_price);\r\n//             const exitPrice = parseFloat(trade.exit_price);\r\n//             const contracts = trade.contracts;\r\n//             if (!isNaN(exitPrice)) {\r\n//               return sum + (exitPrice - entryPrice) * contracts * 100;\r\n//             }\r\n//             return sum;\r\n//           }, 0);\r\n//         }\r\n\r\n//         profitsData.push({\r\n//           timePeriod: selectedTimePeriod,\r\n//           profit: totalProfit,\r\n//           backgroundColor: totalProfit >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\",\r\n//         });\r\n//       });\r\n\r\n//       return profitsData;\r\n//     };\r\n\r\n//     const updateChart = () => {\r\n//       const ctx = chartRef.current.getContext(\"2d\");\r\n//       const profitsData = calculateProfitsForAllTimePeriods(trades);\r\n\r\n//       const myChart = new window.Chart(ctx, {\r\n//         type: \"bar\",\r\n//         data: {\r\n//           labels: profitsData.map((data) => data.timePeriod),\r\n//           datasets: [\r\n//             {\r\n//               label: \"Profit/Loss\",\r\n//               data: profitsData.map((data) => data.profit),\r\n//               backgroundColor: profitsData.map((data) => data.backgroundColor),\r\n//               barThickness: 40, // Adjust thickness as needed\r\n//             },\r\n//           ],\r\n//         },\r\n//         options: {\r\n//           plugins: {\r\n//             legend: {\r\n//               display: false,\r\n//             },\r\n//           },\r\n//           scales: {\r\n//             x: {\r\n//               grid: {\r\n//                 display: false,\r\n//               },\r\n//             },\r\n//             y: {\r\n//               display: true,\r\n//               title: {\r\n//                 display: true,\r\n//                 text: \"Profit/Loss\",\r\n//               },\r\n//               grid: {\r\n//                 color: (context) =>\r\n//                   context.tick.value === 0\r\n//                     ? \"rgba(0, 0, 0, 1)\"\r\n//                     : \"rgba(0, 0, 0, 0)\", // Only show line at 0\r\n//                 lineWidth: 0.5, // Adjust line width as needed\r\n//               },\r\n//               ticks: {\r\n//                 callback: function (value, index, values) {\r\n//                   return value === 0 ? value : \"\";\r\n//                 },\r\n//               },\r\n//             },\r\n//           },\r\n//         },\r\n//       });\r\n\r\n//       return myChart;\r\n//     };\r\n\r\n//     let myChart = updateChart();\r\n//     setLoading(false);\r\n\r\n//     return () => {\r\n//       if (myChart) {\r\n//         myChart.destroy();\r\n//       }\r\n//     };\r\n//   }, [trades]);\r\n\r\n//   return (\r\n//     <div className=\"account-graph\">\r\n//       {loading ? <p>Loading...</p> : <canvas ref={chartRef} />}\r\n//     </div>\r\n//   );\r\n// };\r\n\r\n// export default AccountGraph;\r\n\r\n// // import React, { useEffect, useRef } from \"react\";\r\n// // import \"./styles/accountGraph.css\";\r\n\r\n// // const AccountGraph = ({ trades, onTimePeriodChange }) => {\r\n// //   const chartRef = useRef(null);\r\n\r\n// //   useEffect(() => {\r\n// //     const calculateProfitsForAllTimePeriods = (trades) => {\r\n// //       const timePeriods = [\"1D\", \"1W\", \"1M\", \"3M\", \"YTD\", \"1Y\", \"Max\"];\r\n// //       const profitsData = [];\r\n\r\n// //       timePeriods.forEach((selectedTimePeriod) => {\r\n// //         let startDate = new Date();\r\n// //         let totalProfit = 0;\r\n\r\n// //         switch (selectedTimePeriod) {\r\n// //           case \"1D\":\r\n// //             startDate.setDate(startDate.getDate() - 1);\r\n// //             break;\r\n// //           case \"1W\":\r\n// //             startDate.setDate(startDate.getDate() - 7);\r\n// //             break;\r\n// //           case \"1M\":\r\n// //             startDate.setMonth(startDate.getMonth() - 1);\r\n// //             break;\r\n// //           case \"3M\":\r\n// //             startDate.setMonth(startDate.getMonth() - 3);\r\n// //             break;\r\n// //           case \"YTD\":\r\n// //             startDate = new Date(startDate.getFullYear(), 0, 1); // Year to Date\r\n// //             break;\r\n// //           case \"1Y\":\r\n// //             startDate.setFullYear(startDate.getFullYear() - 1);\r\n// //             break;\r\n// //           case \"Max\":\r\n// //             break;\r\n// //           default:\r\n// //             break;\r\n// //         }\r\n\r\n// //         if (selectedTimePeriod !== \"Max\") {\r\n// //           const filteredTrades = trades.filter(\r\n// //             (trade) => new Date(trade.close_date) >= startDate\r\n// //           );\r\n\r\n// //           totalProfit = filteredTrades.reduce((sum, trade) => {\r\n// //             const entryPrice = parseFloat(trade.entry_price);\r\n// //             const exitPrice = parseFloat(trade.exit_price);\r\n// //             const contracts = trade.contracts;\r\n// //             if (!isNaN(exitPrice)) {\r\n// //               return sum + (exitPrice - entryPrice) * contracts * 100;\r\n// //             }\r\n// //             return sum;\r\n// //           }, 0);\r\n// //         } else {\r\n// //           totalProfit = trades.reduce((sum, trade) => {\r\n// //             const entryPrice = parseFloat(trade.entry_price);\r\n// //             const exitPrice = parseFloat(trade.exit_price);\r\n// //             const contracts = trade.contracts;\r\n// //             if (!isNaN(exitPrice)) {\r\n// //               return sum + (exitPrice - entryPrice) * contracts * 100;\r\n// //             }\r\n// //             return sum;\r\n// //           }, 0);\r\n// //         }\r\n\r\n// //         profitsData.push({\r\n// //           timePeriod: selectedTimePeriod,\r\n// //           profit: totalProfit,\r\n// //           backgroundColor: totalProfit >= 0 ? \"#bed1be\" : \"rgb(255, 204, 204)\",\r\n// //         });\r\n// //       });\r\n\r\n// //       return profitsData;\r\n// //     };\r\n\r\n// //     const ctx = chartRef.current.getContext(\"2d\");\r\n// //     const profitsData = calculateProfitsForAllTimePeriods(trades);\r\n\r\n// //     const myChart = new window.Chart(ctx, {\r\n// //       type: \"bar\",\r\n// //       data: {\r\n// //         labels: profitsData.map((data) => data.timePeriod),\r\n// //         datasets: [\r\n// //           {\r\n// //             label: \"Profit/Loss\",\r\n// //             data: profitsData.map((data) => data.profit),\r\n// //             backgroundColor: profitsData.map((data) => data.backgroundColor),\r\n// //             barThickness: 40, // Adjust thickness as needed\r\n// //           },\r\n// //         ],\r\n// //       },\r\n// //       options: {\r\n// //         plugins: {\r\n// //           legend: {\r\n// //             display: false,\r\n// //           },\r\n// //         },\r\n// //         scales: {\r\n// //           x: {\r\n// //             grid: {\r\n// //               display: false,\r\n// //             },\r\n// //           },\r\n// //           y: {\r\n// //             display: true,\r\n// //             title: {\r\n// //               display: true,\r\n// //               text: \"Profit/Loss\",\r\n// //             },\r\n// //             grid: {\r\n// //               color: (context) =>\r\n// //                 context.tick.value === 0\r\n// //                   ? \"rgba(0, 0, 0, 1)\"\r\n// //                   : \"rgba(0, 0, 0, 0)\", // Only show line at 0\r\n// //               lineWidth: 0.5, // Adjust line width as needed\r\n// //             },\r\n// //             ticks: {\r\n// //               callback: function (value, index, values) {\r\n// //                 return value === 0 ? value : \"\";\r\n// //               },\r\n// //             },\r\n// //           },\r\n// //         },\r\n// //       },\r\n// //     });\r\n\r\n// //     return () => {\r\n// //       myChart.destroy();\r\n// //     };\r\n// //   }, [trades]);\r\n\r\n// //   return (\r\n// //     <div className=\"account-graph\">\r\n// //       <canvas ref={chartRef} />\r\n// //     </div>\r\n// //   );\r\n// // };\r\n\r\n// // export default AccountGraph;\r\n"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA"},"metadata":{},"sourceType":"module"}